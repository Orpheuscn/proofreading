<!DOCTYPE html>
<html lang="zh-CN" data-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>手工校译</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdn.jsdelivr.net/npm/daisyui@4.4.19/dist/full.min.css" rel="stylesheet" type="text/css" />

    <style>
        /* 核心修改：通过增加 padding 来扩大悬停区域 */
        .align-row {
            display: flex;
            border-bottom: 1px solid oklch(var(--b3));
            position: relative;
            /* 关键修改：增加左右 padding，让按钮区域被包含在悬停范围内 */
            padding-left: 50px; 
            padding-right: 50px;
        }
        
        .align-cell {
            flex: 1;
            padding: 1rem;
            white-space: pre-wrap;
            word-break: break-word;
            outline: none;
        }
        
        .align-cell:first-child {
            border-right: 1px solid oklch(var(--b3));
            background-color: oklch(var(--b2)); 
        }

        .align-cell[contenteditable="true"] {
            box-shadow: inset 0 0 0 1px oklch(var(--p) / 0.3);
        }

        /* 悬浮显示的插入按钮 */
        .insert-btns {
            position: absolute;
            left: 50px; /* 调整：对齐到 align-row 的内容区域左侧边界 */
            right: 50px; /* 调整：对齐到 align-row 的内容区域右侧边界 */
            bottom: -12px;
            height: 24px;
            display: flex;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 10;
            pointer-events: none;
        }
        
        .align-row:hover .insert-btns {
            opacity: 1;
            pointer-events: auto;
        }
        
        .insert-btns > div {
            flex: 1;
            display: flex;
            justify-content: center;
        }
        
        .insert-btns > div:first-child {
            border-right: 1px solid transparent;
        }
        
        /* 删除按钮 */
        .delete-btn-left,
        .delete-btn-right {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 10;
            pointer-events: none;
        }
        
        /* 关键修改：将定位调整到 align-row 内部 padding 的边界 */
        .delete-btn-left {
            left: 0; 
        }
        
        .delete-btn-right {
            right: 0;
        }
        
        .align-row:hover .delete-btn-left,
        .align-row:hover .delete-btn-right {
            opacity: 1;
            pointer-events: auto;
        }
    </style>
</head>
<body class="min-h-screen bg-base-200 p-6">

    <div class="container mx-auto max-w-7xl">
        <div class="text-center mb-8">
            <h1 class="text-4xl font-bold text-base-content">手工校译</h1>
        </div>

        <div class="collapse collapse-arrow bg-base-100 shadow-xl mb-8">
            <input type="checkbox" checked /> 
            <div class="collapse-title text-xl font-medium">
                原始文本输入区
            </div>
            <div class="collapse-content">
                <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mt-4">
                    <div class="form-control">
                        <label class="label"><span class="label-text">左侧文本</span></label>
                        <textarea id="leftText" class="textarea textarea-bordered h-48 text-base leading-relaxed" placeholder="在此输入左侧文本..."></textarea>
                    </div>

                    <div class="form-control">
                        <label class="label"><span class="label-text">右侧文本</span></label>
                        <textarea id="rightText" class="textarea textarea-bordered h-48 text-base leading-relaxed" placeholder="在此输入右侧文本..."></textarea>
                    </div>
                </div>
                
                <div class="flex flex-wrap justify-center gap-4 mt-6 mb-2">
                    <button onclick="startAlign()" class="btn btn-accent shadow-lg text-lg min-w-[160px]">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16" /></svg>
                        开始对齐
                    </button>
                </div>
            </div>
        </div>

        <div class="card bg-base-100 shadow-xl">
             <div class="bg-base-300 px-4 py-2 flex border-b border-base-content/10 rounded-t-box">
                <div class="flex-1 flex justify-between items-center pr-4 border-r border-base-content/10">
                    <span class="font-bold text-base-content/70">左侧文本</span>
                </div>
                
                <div class="flex-1 flex justify-between items-center pl-4">
                    <span class="font-bold text-base-content/70">右侧文本</span>
                    <button class="btn btn-sm btn-secondary" onclick="copyRightText()" title="复制全部文本">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 5H6a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2v-1M8 5a2 2 0 002 2h2a2 2 0 002-2M8 5a2 2 0 012-2h2a2 2 0 012 2m0 0h2a2 2 0 012 2v3m2 4H10m0 0l3-3m-3 3l3 3" /></svg>
                        复制
                    </button>
                </div>
            </div>

            <div class="card-body p-0">
                <div id="result" class="flex flex-col rounded-b-box min-h-[200px]" style="overflow: visible;">
                    <div class="p-8 text-center text-base-content/50">请在上方的输入框中输入文本，然后点击"开始对齐"</div>
                </div>
            </div>
        </div>
    </div>

    <div class="toast toast-top toast-center z-50" id="toast-container"></div>

    <script>
    
    // 开始对齐 - 预处理输入，过滤空行
    function startAlign() {
        const leftText = document.getElementById('leftText');
        const rightText = document.getElementById('rightText');
        
        // 过滤掉空行和只有空格的行
        const leftFiltered = leftText.value.split('\n').filter(p => p.trim() !== '').join('\n');
        const rightFiltered = rightText.value.split('\n').filter(p => p.trim() !== '').join('\n');
        
        leftText.value = leftFiltered;
        rightText.value = rightFiltered;
        
        // 调用对齐显示
        alignText();
    }

    // 复制右侧文本
    function copyRightText() {
        // 从当前显示的右侧单元格中收集文本
        const cells = document.querySelectorAll('.right-cell');
        const paragraphs = [];
        cells.forEach(cell => {
            paragraphs.push(cell.innerText.trim());
        });
        const text = paragraphs.join('\n');
        
        if (!text) {
            alert('右侧没有可复制的文本');
            return;
        }
        
        navigator.clipboard.writeText(text).then(() => {
            alert('右侧文本已复制到剪贴板');
        }).catch(err => {
            console.error('复制失败:', err);
            alert('复制失败，请手动复制');
        });
    }
    
    // 保存单侧的编辑内容回textarea
    function saveEdits(side) {
        const cells = document.querySelectorAll(side === 'left' ? '.left-cell' : '.right-cell');
        const paragraphs = [];
        cells.forEach(cell => {
            const text = cell.innerText.trim();
            // 在保存回 textarea 时，空内容我们用单个空格占位，以保持行数对齐
            // 否则如果单元格内容是空的，join('\n') 会导致行数减少，影响 insert/delete 的索引计算
            paragraphs.push(text === '' ? ' ' : text); 
        });
        const textArea = side === 'left' ? document.getElementById('leftText') : document.getElementById('rightText');
        // 用换行符连接，保持简单
        textArea.value = paragraphs.join('\n');
    }

    // 对齐显示
    function alignText() {
        const leftRaw = document.getElementById('leftText').value;
        const rightRaw = document.getElementById('rightText').value;
        
        // 用换行符分割段落（不过滤，保持所有行包括空行）
        // 如果 textarea 是空的，split('\n') 结果是 ['']，所以需要特殊处理
        const leftParagraphs = leftRaw.split('\n');
        const rightParagraphs = rightRaw.split('\n');
        
        const maxLen = Math.max(leftParagraphs.length, rightParagraphs.length);
        const resultContainer = document.getElementById('result');
        
        resultContainer.innerHTML = ''; 

        if (maxLen === 0 || (leftParagraphs.length === 1 && leftParagraphs[0] === '' && rightParagraphs.length === 1 && rightParagraphs[0] === '')) {
             resultContainer.innerHTML = '<div class="p-8 text-center text-base-content/50">没有输入内容</div>';
             return;
         }


        // 为每个段落创建独立的行
        for (let i = 0; i < maxLen; i++) {
            const row = document.createElement('div');
            row.className = 'align-row hover:bg-base-200/50 transition-colors';
            row.dataset.index = i;

            // 左侧单元格 - 默认可编辑
            const leftCell = document.createElement('div');
            leftCell.className = 'align-cell text-base-content left-cell';
            leftCell.contentEditable = 'true';
            leftCell.dataset.index = i;
            // 确保显示的内容是 trim 后的结果，但如果是 ' ' 占位符，显示为空
            let leftTextContent = leftParagraphs[i] || '';
            leftCell.textContent = leftTextContent.trim() === '' ? '' : leftTextContent;
            leftCell.oninput = () => saveEdits('left');
            
            // 右侧单元格 - 默认可编辑
            const rightCell = document.createElement('div');
            rightCell.className = 'align-cell text-base-content right-cell';
            rightCell.contentEditable = 'true';
            rightCell.dataset.index = i;
            let rightTextContent = rightParagraphs[i] || '';
            rightCell.textContent = rightTextContent.trim() === '' ? '' : rightTextContent;
            rightCell.oninput = () => saveEdits('right');

            row.appendChild(leftCell);
            row.appendChild(rightCell);
            
            // 添加左侧删除按钮
            const deleteLeftBtn = document.createElement('button');
            deleteLeftBtn.className = 'btn btn-circle btn-xs btn-error delete-btn-left';
            deleteLeftBtn.innerHTML = '×';
            deleteLeftBtn.onclick = () => deleteRowAt('left', row);
            row.appendChild(deleteLeftBtn);
            
            // 添加右侧删除按钮
            const deleteRightBtn = document.createElement('button');
            deleteRightBtn.className = 'btn btn-circle btn-xs btn-error delete-btn-right';
            deleteRightBtn.innerHTML = '×';
            deleteRightBtn.onclick = () => deleteRowAt('right', row);
            row.appendChild(deleteRightBtn);
            
            // 添加插入按钮
            const insertBtns = document.createElement('div');
            insertBtns.className = 'insert-btns';
            
            const leftBtnDiv = document.createElement('div');
            const leftBtn = document.createElement('button');
            leftBtn.className = 'btn btn-circle btn-xs btn-primary';
            leftBtn.textContent = '+';
            leftBtn.onclick = () => insertRowAt('left', row);
            leftBtnDiv.appendChild(leftBtn);
            
            const rightBtnDiv = document.createElement('div');
            const rightBtn = document.createElement('button');
            rightBtn.className = 'btn btn-circle btn-xs btn-primary';
            rightBtn.textContent = '+';
            rightBtn.onclick = () => insertRowAt('right', row);
            rightBtnDiv.appendChild(rightBtn);
            
            insertBtns.appendChild(leftBtnDiv);
            insertBtns.appendChild(rightBtnDiv);
            row.appendChild(insertBtns);
            
            resultContainer.appendChild(row);
        }
    }
    
     // 删除指定行 - 只删除点击的一侧
     function deleteRowAt(side, currentRow) {
         // 先保存当前编辑内容
         saveEdits('left');
         saveEdits('right');
         
         // 获取当前行的索引
         const rows = document.querySelectorAll('.align-row');
         let rowIndex = 0;
         for (let i = 0; i < rows.length; i++) {
             if (rows[i] === currentRow) {
                 rowIndex = i;
                 break;
             }
         }
         
         // 读取对应侧的textarea并分割
         const textArea = side === 'left' ? document.getElementById('leftText') : document.getElementById('rightText');
         const paragraphs = textArea.value ? textArea.value.split('\n') : [];
         
         // 删除指定位置的行
         if (paragraphs.length > rowIndex) {
             paragraphs.splice(rowIndex, 1);
         }
         
         // 保存回textarea
         textArea.value = paragraphs.join('\n');
         
         // 重新渲染
         alignText();
     }
     
     // 使用DOM操作插入新行 - 只在点击的一侧插入
     function insertRowAt(side, currentRow) {
         // 先保存当前编辑内容
         saveEdits('left');
         saveEdits('right');
         
         // 获取当前行的索引
         const rows = document.querySelectorAll('.align-row');
         let rowIndex = 0;
         for (let i = 0; i < rows.length; i++) {
             if (rows[i] === currentRow) {
                 rowIndex = i;
                 break;
             }
         }
         
         // 读取对应侧的textarea并分割（不过滤空行，保持原始数据）
         const textArea = side === 'left' ? document.getElementById('leftText') : document.getElementById('rightText');
         const paragraphs = textArea.value ? textArea.value.split('\n') : [];
         
         // 在当前位置后插入空行（用空格作为占位符，避免被trim过滤）
         paragraphs.splice(rowIndex + 1, 0, ' ');
         
         // 保存回textarea
         textArea.value = paragraphs.join('\n');
         
         // 重新渲染
         alignText();
         
         // 聚焦到新插入的单元格并清空占位符
         setTimeout(() => {
             const cells = document.querySelectorAll(side === 'left' ? '.left-cell' : '.right-cell');
             // 注意索引是 rowIndex + 1
             if (cells[rowIndex + 1]) {
                 cells[rowIndex + 1].textContent = ''; // 清空占位符
                 cells[rowIndex + 1].focus();
             }
         }, 50);
     }

</script>
</body>
</html>